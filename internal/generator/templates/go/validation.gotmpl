// Code generated by promener. DO NOT EDIT.
package {{ .PackageName }}

import (
	"fmt"

	"github.com/google/cel-go/cel"
	"github.com/google/cel-go/common/types"
)

var (
	celEnv      *cel.Env
	celPrograms = make(map[string]cel.Program)
)

func init() {
	var err error
	celEnv, err = cel.NewEnv(cel.Variable("value", cel.StringType))
	if err != nil {
		panic(fmt.Sprintf("failed to create CEL environment: %v", err))
	}

	// Compile all validation expressions
	validations := map[string]string{
		{{- range $ns := .Namespaces }}
		{{- range $ss := $ns.Subsystems }}
		{{- range $m := $ss.Metrics }}
		{{- range $label := $m.LabelDefinitions }}
		{{- range $validation := $label.Validations }}
		"{{ $ns.Name }}_{{ $ss.Name }}_{{ $m.MethodName }}_{{ $label.Name }}_{{ $validation }}": "{{ $validation }}",
		{{- end }}
		{{- end }}
		{{- end }}
		{{- end }}
		{{- end }}
	}

	for key, expr := range validations {
		ast, issues := celEnv.Compile(expr)
		if issues != nil && issues.Err() != nil {
			panic(fmt.Sprintf("failed to compile CEL expression %q: %v", expr, issues.Err()))
		}
		program, err := celEnv.Program(ast)
		if err != nil {
			panic(fmt.Sprintf("failed to create CEL program for %q: %v", expr, err))
		}
		celPrograms[key] = program
	}
}

// validateLabel runs a CEL validation on a label value
func validateLabel(programKey, labelName, value string) error {
	program, exists := celPrograms[programKey]
	if !exists {
		return nil // No validation for this label
	}

	result, _, err := program.Eval(map[string]interface{}{"value": value})
	if err != nil {
		return fmt.Errorf("label %q validation error: %w", labelName, err)
	}

	boolResult, ok := result.(types.Bool)
	if !ok {
		return fmt.Errorf("label %q validation did not return boolean", labelName)
	}

	if boolResult == types.False {
		return fmt.Errorf("label %q value %q failed validation", labelName, value)
	}

	return nil
}
