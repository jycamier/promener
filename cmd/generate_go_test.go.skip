package cmd

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/jycamier/promener/internal/domain"
	"github.com/jycamier/promener/internal/generator"
	"github.com/jycamier/promener/internal/generator/mocks"
	"github.com/jycamier/promener/internal/validator"
	validatorMocks "github.com/jycamier/promener/internal/validator/mocks"
	"go.uber.org/mock/gomock"
)

func TestGoGenerateCommand(t *testing.T) {
	tests := []struct {
		name         string
		args         []string
		mockSetup    func(*validatorMocks.MockSpecValidator, *mocks.MockMetricsGenerator, *mocks.MockDIGenerator)
		wantErr      bool
		errorContains string
	}{
		{
			name: "successful generation without DI",
			args: []string{"-i", "testdata/test.cue", "-o", "testoutput"},
			mockSetup: func(mv *validatorMocks.MockSpecValidator, mg *mocks.MockMetricsGenerator, md *mocks.MockDIGenerator) {
				spec := &domain.Specification{
					Info: domain.Info{Title: "Test", Version: "1.0.0"},
					Services: map[string]domain.Service{
						"default": {
							Info: domain.Info{Title: "Default Service", Version: "1.0.0"},
							Metrics: map[string]domain.Metric{
								"test_metric": {
									Name: "test_metric",
									Type: domain.MetricTypeCounter,
									Help: "Test metric",
								},
							},
						},
					},
				}
				result := &validator.ValidationResult{
					Valid:     true,
					CueErrors: []validator.ValidationError{},
				}
				mv.EXPECT().
					ValidateAndExtract("testdata/test.cue").
					Return(spec, result, nil).
					Times(1)

				mg.EXPECT().
					GenerateMetrics(spec).
					Return(nil).
					Times(1)
			},
			wantErr: false,
		},
		{
			name: "successful generation with DI and FX",
			args: []string{"-i", "testdata/test.cue", "-o", "testoutput", "--di", "--fx"},
			mockSetup: func(mv *validatorMocks.MockSpecValidator, mg *mocks.MockMetricsGenerator, md *mocks.MockDIGenerator) {
				spec := &domain.Specification{
					Info: domain.Info{Title: "Test", Version: "1.0.0"},
					Services: map[string]domain.Service{
						"default": {
							Info: domain.Info{Title: "Default Service", Version: "1.0.0"},
							Metrics: map[string]domain.Metric{
								"test_metric": {
									Name: "test_metric",
									Type: domain.MetricTypeCounter,
									Help: "Test metric",
								},
							},
						},
					},
				}
				result := &validator.ValidationResult{
					Valid:     true,
					CueErrors: []validator.ValidationError{},
				}
				mv.EXPECT().
					ValidateAndExtract("testdata/test.cue").
					Return(spec, result, nil).
					Times(1)

				mg.EXPECT().
					GenerateMetrics(spec).
					Return(nil).
					Times(1)

				md.EXPECT().
					GenerateDI(spec).
					Return(nil).
					Times(1)
			},
			wantErr: false,
		},
		{
			name: "validation error",
			args: []string{"-i", "testdata/invalid.cue", "-o", "testoutput"},
			mockSetup: func(mv *validatorMocks.MockSpecValidator, mg *mocks.MockMetricsGenerator, md *mocks.MockDIGenerator) {
				result := &validator.ValidationResult{
					Valid:     false,
					CueErrors: []validator.ValidationError{
						{
							Path:    "services.default.metrics.test",
							Message: "missing required field 'type'",
							Line:    10,
						},
					},
				}
				mv.EXPECT().
					ValidateAndExtract("testdata/invalid.cue").
					Return(nil, result, nil).
					Times(1)
			},
			wantErr:       true,
			errorContains: "failed to validate specification",
		},
		{
			name:          "DI without FX error",
			args:          []string{"-i", "testdata/test.cue", "-o", "testoutput", "--di"},
			mockSetup:     func(mv *validatorMocks.MockSpecValidator, mg *mocks.MockMetricsGenerator, md *mocks.MockDIGenerator) {},
			wantErr:       true,
			errorContains: "--di requires a DI framework flag (--fx)",
		},
		{
			name: "custom package name from -p flag",
			args: []string{"-i", "testdata/test.cue", "-o", "testoutput", "-p", "custompackage"},
			mockSetup: func(mv *validatorMocks.MockSpecValidator, mg *mocks.MockMetricsGenerator, md *mocks.MockDIGenerator) {
				spec := &domain.Specification{
					Info: domain.Info{Title: "Test", Version: "1.0.0"},
					Services: map[string]domain.Service{
						"default": {
							Info: domain.Info{Title: "Default Service", Version: "1.0.0"},
							Metrics: map[string]domain.Metric{
								"test_metric": {
									Name: "test_metric",
									Type: domain.MetricTypeCounter,
									Help: "Test metric",
								},
							},
						},
					},
				}
				result := &validator.ValidationResult{
					Valid:     true,
					CueErrors: []validator.ValidationError{},
				}
				mv.EXPECT().
					ValidateAndExtract("testdata/test.cue").
					Return(spec, result, nil).
					Times(1)

				mg.EXPECT().
					GenerateMetrics(spec).
					Return(nil).
					Times(1)
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup test output directory
			tmpDir := filepath.Join(os.TempDir(), "promener_test_"+tt.name)
			defer os.RemoveAll(tmpDir)

			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockValidator := validatorMocks.NewMockSpecValidator(ctrl)
			mockMetricsGen := mocks.NewMockMetricsGenerator(ctrl)
			mockDIGen := mocks.NewMockDIGenerator(ctrl)

			if tt.mockSetup != nil {
				tt.mockSetup(mockValidator, mockMetricsGen, mockDIGen)
			}

			// Note: In a real implementation, we would need to inject these mocks
			// into the command. For now, this test demonstrates the structure.
			// To make this fully testable, we'd need to refactor cmd/generate_go.go
			// to accept injected dependencies.

			// Execute command
			goCmd.SetArgs(tt.args)
			err := goCmd.Execute()

			// Check error
			if (err != nil) != tt.wantErr {
				t.Errorf("goCmd.Execute() error = %v, wantErr %v", err, tt.wantErr)
			}

			if tt.wantErr && tt.errorContains != "" && err != nil {
				if err.Error() != tt.errorContains && !contains(err.Error(), tt.errorContains) {
					t.Errorf("goCmd.Execute() error = %v, should contain %q", err, tt.errorContains)
				}
			}
		})
	}
}

// Helper function to check if a string contains a substring
func contains(s, substr string) bool {
	return len(s) >= len(substr) && s[:len(substr)] == substr ||
		len(s) > len(substr) && contains(s[1:], substr)
}

func TestGoGenerateCommand_PackageNameFromDir(t *testing.T) {
	// Test that package name defaults to output directory basename
	tmpDir := filepath.Join(os.TempDir(), "mypackage")
	defer os.RemoveAll(tmpDir)

	err := os.MkdirAll(tmpDir, 0755)
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}

	basename := filepath.Base(tmpDir)
	if basename != "mypackage" {
		t.Errorf("Expected basename 'mypackage', got %q", basename)
	}
}

func TestGoGenerateCommand_GeneratorCreation(t *testing.T) {
	// Test that generator can be created with package name and output dir
	tmpDir := filepath.Join(os.TempDir(), "testgen")
	defer os.RemoveAll(tmpDir)

	err := os.MkdirAll(tmpDir, 0755)
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}

	gen, err := generator.NewGolangGenerator("testpackage", tmpDir)
	if err != nil {
		t.Errorf("NewGolangGenerator() error = %v, want nil", err)
	}

	if gen == nil {
		t.Error("NewGolangGenerator() returned nil generator")
	}
}
