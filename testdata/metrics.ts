// This code was generated by Promener
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

import { Registry, Counter, Gauge, Histogram, Summary } from 'prom-client';

/**
 * Interface for Http.Server metrics
 */
export interface IHttpServerMetrics {
  /**
   * Observe a value for request_duration_seconds
   */
  observeRequestDurationSeconds(method: string, endpoint: string, value: number): void;
  /**
   * Set active_connections to a specific value
   */
  setActiveConnections(protocol: string, value: number): void;

  /**
   * Increment active_connections by 1
   */
  incActiveConnections(protocol: string): void;

  /**
   * Decrement active_connections by 1
   */
  decActiveConnections(protocol: string): void;

  /**
   * Add a value to active_connections
   */
  addActiveConnections(protocol: string, value: number): void;

  /**
   * Subtract a value from active_connections
   */
  subActiveConnections(protocol: string, value: number): void;
  /**
   * Observe a value for response_size_bytes
   */
  observeResponseSizeBytes(method: string, value: number): void;
  /**
   * Increment requests_total by 1
   */
  incRequestsTotal(method: string, status: string, endpoint: string): void;

  /**
   * Increment requests_total by a specific value
   */
  addRequestsTotal(method: string, status: string, endpoint: string, value: number): void;
}

/**
 * Implementation of Http.Server metrics
 */
export class HttpServerMetricsImpl implements IHttpServerMetrics {
  private readonly _requestDurationSeconds: Histogram;
  private readonly _activeConnections: Gauge;
  private readonly _responseSizeBytes: Summary;
  private readonly _requestsTotal: Counter;

  constructor(registry: Registry) {
    this._requestDurationSeconds = new Histogram({
      name: 'http_server_request_duration_seconds',
      help: 'HTTP request duration in seconds',
      registers: [registry],
      labelNames: ['method', 'endpoint'],
      buckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10],
    });
    this._activeConnections = new Gauge({
      name: 'http_server_active_connections',
      help: 'Number of active connections',
      registers: [registry],
      labelNames: ['protocol'],
    });
    this._responseSizeBytes = new Summary({
      name: 'http_server_response_size_bytes',
      help: 'Response size in bytes',
      registers: [registry],
      labelNames: ['method'],
      percentiles: [0.5,0.9,0.99,],
    });
    this._requestsTotal = new Counter({
      name: 'http_server_requests_total',
      help: 'Total number of HTTP requests',
      registers: [registry],
      labelNames: ['method', 'status', 'endpoint'],
    });
  }

  observeRequestDurationSeconds(method: string, endpoint: string, value: number): void {
    this._requestDurationSeconds.observe({method, endpoint }, value);
  }

  setActiveConnections(protocol: string, value: number): void {
    this._activeConnections.set({protocol }, value);
  }

  incActiveConnections(protocol: string): void {
    this._activeConnections.inc({protocol });
  }

  decActiveConnections(protocol: string): void {
    this._activeConnections.dec({protocol });
  }

  addActiveConnections(protocol: string, value: number): void {
    this._activeConnections.inc({protocol }, value);
  }

  subActiveConnections(protocol: string, value: number): void {
    this._activeConnections.dec({protocol }, value);
  }

  observeResponseSizeBytes(method: string, value: number): void {
    this._responseSizeBytes.observe({method }, value);
  }

  incRequestsTotal(method: string, status: string, endpoint: string): void {
    this._requestsTotal.inc({method, status, endpoint });
  }

  addRequestsTotal(method: string, status: string, endpoint: string, value: number): void {
    this._requestsTotal.inc({method, status, endpoint }, value);
  }
}

/**
 * Interface for Db.Postgres metrics
 */
export interface IDbPostgresMetrics {
  /**
   * Increment queries_total by 1
   */
  incQueriesTotal(operation: string, table: string): void;

  /**
   * Increment queries_total by a specific value
   */
  addQueriesTotal(operation: string, table: string, value: number): void;
  /**
   * Observe a value for query_duration_seconds
   */
  observeQueryDurationSeconds(operation: string, table: string, value: number): void;
  /**
   * Set connection_pool_size to a specific value
   */
  setConnectionPoolSize(state: string, value: number): void;

  /**
   * Increment connection_pool_size by 1
   */
  incConnectionPoolSize(state: string): void;

  /**
   * Decrement connection_pool_size by 1
   */
  decConnectionPoolSize(state: string): void;

  /**
   * Add a value to connection_pool_size
   */
  addConnectionPoolSize(state: string, value: number): void;

  /**
   * Subtract a value from connection_pool_size
   */
  subConnectionPoolSize(state: string, value: number): void;
}

/**
 * Implementation of Db.Postgres metrics
 */
export class DbPostgresMetricsImpl implements IDbPostgresMetrics {
  private readonly _queriesTotal: Counter;
  private readonly _queryDurationSeconds: Histogram;
  private readonly _connectionPoolSize: Gauge;

  constructor(registry: Registry) {
    this._queriesTotal = new Counter({
      name: 'db_postgres_queries_total',
      help: 'Total number of database queries',
      registers: [registry],
      labelNames: ['operation', 'table'],
    });
    this._queryDurationSeconds = new Histogram({
      name: 'db_postgres_query_duration_seconds',
      help: 'Database query duration in seconds',
      registers: [registry],
      labelNames: ['operation', 'table'],
      buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5],
    });
    this._connectionPoolSize = new Gauge({
      name: 'db_postgres_connection_pool_size',
      help: 'Current database connection pool size',
      registers: [registry],
      labelNames: ['state'],
    });
  }

  incQueriesTotal(operation: string, table: string): void {
    this._queriesTotal.inc({operation, table });
  }

  addQueriesTotal(operation: string, table: string, value: number): void {
    this._queriesTotal.inc({operation, table }, value);
  }

  observeQueryDurationSeconds(operation: string, table: string, value: number): void {
    this._queryDurationSeconds.observe({operation, table }, value);
  }

  setConnectionPoolSize(state: string, value: number): void {
    this._connectionPoolSize.set({state }, value);
  }

  incConnectionPoolSize(state: string): void {
    this._connectionPoolSize.inc({state });
  }

  decConnectionPoolSize(state: string): void {
    this._connectionPoolSize.dec({state });
  }

  addConnectionPoolSize(state: string, value: number): void {
    this._connectionPoolSize.inc({state }, value);
  }

  subConnectionPoolSize(state: string, value: number): void {
    this._connectionPoolSize.dec({state }, value);
  }
}

/**
 * Main metrics registry
 */
export class MetricsRegistry {
  public readonly registry: Registry;
  public readonly httpServer: IHttpServerMetrics;
  public readonly dbPostgres: IDbPostgresMetrics;

  private static _instance: MetricsRegistry | null = null;

  /**
   * Gets the default singleton instance
   */
  static get default(): MetricsRegistry {
    if (!MetricsRegistry._instance) {
      MetricsRegistry._instance = new MetricsRegistry();
    }
    return MetricsRegistry._instance;
  }

  constructor(registry?: Registry) {
    this.registry = registry || new Registry();
    this.httpServer = new HttpServerMetricsImpl(this.registry);
    this.dbPostgres = new DbPostgresMetricsImpl(this.registry);
  }

  /**
   * Get metrics in Prometheus format
   */
  async getMetrics(): Promise<string> {
    return this.registry.metrics();
  }
}
